---
title: 《程序员修炼之道》-阅读笔记
date: 2021-02-28 11:37:21
categories: [Book]
tags: [Book,Learning]
---

## 注重实效的程序员有哪些特征
* **早期的采纳者/快速的改编者。**你具有技术和技巧上的直觉，你喜爱实验各种事物。给你一样新东西，你很快就能把握它，并把它与你的知识的其余部分结合在一起。你的自信出自经验。
* **好奇。**你喜欢提问。那很漂亮——你是怎么做的？你用那个库时有问题吗？……你是收集小知识的林鼠，每一条小知识都可能会影响今后几年里的某项决策。
* **批判的思考者。**你不会不首先抓住事实而照搬别人的说法。当同事说“因为就该那么做”或者供应商允诺为你的全部问题提供解决方案时，及就会嗅到挑战的气息。
* **有现实感。**你会设法理解你面临的每个问题的内在本质。这样的现实主义给了你良好的感知能力：事情有多困难，需要多长时间？让你自己了解某个过程会有困难，或者要用多一点时间才能完成，能够给予你坚持不懈的毅力。
* **多才多艺。**你尽力熟悉广泛的技术和环境，并且努力工作，以与各种新发展并肩前行。尽管你现在的工作也许只要求你成为某方面的专才，你却总是能够转向新的领域和新的挑战。

我们把最基本的特征留到最后。所有注重实效的程序员都具有这些特征。它们基本的足以用提示的方式来陈述：
* **Care About Your Craft——关心你的技艺。**我们觉得除非你在乎能否漂亮的开发出软件，否则其他事情都是没有意义的。
* **Think! About Your Work——思考！你的工作。**为了让你成为注重实效的程序员，我们向你发出挑战：在你做某件事情的时候思考你在做什么。这不是对当前实践的一次性审计——它是对你每一天、在每一次开发上所做出的每一项决策的批判评估。不要依靠自动驾驶仪。不间断地思考，实时地批判你的工作。

<!-- more -->

## 我的源码让猫吃了
如果磁盘垮了，带走了你所有的源码，而你没有做好备份，那是你的错。告诉你的老板“我的源码让猫吃了”也无法改变这一点。
**Provide Options, Don't Make Lame Excuses——提供各种选择，不要找蹩脚的借口。**
责任是你主动承担的东西。你不一定能控制事情的每一个方面，所以在你承诺确保某件事情正确完成之前，你必须分析风险是否超出了你的控制。对于不可能做到的事情或是风险太大的事情，你有权不去为之负责。如果你确实同意要为某个结果负责，你就应该切实负起责任。当你犯错误、或是判断失误时，诚实的承认它，并设法给出各种选择。不要责备别人或别人的东西，或者拼凑借口。不要说事情做不到；要说明能够做什么来挽回局面。

## 软件的熵
类似于物理学中熵的概念，当软件中的无序增长时，程序员们称之为“软件腐烂”。有许多因素可以促生软件腐烂，其中最重要的一个似乎是开发项目时的心理（或文化）。
**破窗户理论：**一扇破窗户，只要有那么一段时间不修理，就会渐渐给建筑的居民带来一种废弃感。于是又一扇窗户破了，人们开始乱扔垃圾，出现了乱涂乱画，严重的结构损坏开始了。在较短的一段时间里，建筑就被损坏到超出业主愿意修理的程度，而废弃感变成了现实。
**Don't Live With Broken Windows——不要容忍破窗户。**
破窗户理论启发人们，要对一些轻微的案件严加处理，以防止事情往严重的方向发展。在软件开发中，我们也不要留着破窗户不修。低劣的设计、错误的决策、或者是糟糕的代码，发现一个就修一个。如果没有足够的时间进行修理，也应该采取行动防止进一步的损坏，并说明事态处在你的控制之下。例如，把问题的代码注释起来，或者显示“未实现”标记，或是用虚拟数据加以替代。

## 交流
没有有效的交流，一个好想法就只是一个无人关心的孤儿。我们的时间有很大一部分都花在交流上，所以我们需要把它做好。
* **知道你想要说什么。**规划你想要说的东西，写出大纲，然后问你自己：“这是否讲清了我要说的所有内容？”提炼它，直到确实如此为止。
* **了解你的听众。**尝试问自己WISDOM离合诗，在脑海里形成一幅明确的关于你的听众的画面。
    * **What** do you want them to learn?——你想让他们学到什么？
    * What is their **interest** in what you've got to say?——他们对你讲的什么感兴趣？
    * How **sophisticated** are they?——他们有多富有经验？
    * How much **detail** to they want?——他们想要多少细节？
    * Whom do you want to **own** the information?——你想要让谁拥有这些信息？
    * How can you **motivate** them to listen you?——你如何促使他们听你说话？
* **选择时机。**了解你的听众需要听到什么，在适当的时机说，你将会拥有一个更容易接纳的倾听者。
* **选择风格。**有人喜欢详细的文档、有人喜欢简单的报告，调整你的交流风格，让其适应你的听众。
* **让文档美观。**你的主意应该以美观的方式传递给你的听众，否则糟糕的外观可能会毁掉你的努力。
* **让听众参与。**让你的读者参与文档的早期草稿制作，获取他们的反馈，有助于制作出更好的文档。
* **做倾听者。**通过提问来交谈，把会议变成对话，你将能更有效地阐明你的观点。
* **回复他人。**及时回应提问、回复邮件，随时通知别人，会让他们更容易原谅你偶然的疏忽，并让他们觉得你没有忘记他们。

**It's Both What You Say and the Way You Say It——你说什么和你怎么说同样重要。**
除非你生活在真空中，你才不需要交流。交流越有效，你就越有影响力。

## 重复的危害
在我们开发的规范、过程和程序中很容易重复表述知识，这将是后续维护工作的噩梦。我们觉得，可靠地开发软件、并让我们的开发更易于理解和维护的唯一途径，是遵循我们称之为DRY的原则：系统中的每一项知识都必须具有单一、无歧义、权威的表示。
**DRY——Don't Repeat Yourself——不要重复你自己。**
在不同的地方表达同一事物，意味着你改变其中一处，就必须得记得改变其他各处，否则你的程序将因为自相矛盾而被迫屈服。这不是你能否记住的问题，而是你何时忘记的问题。我们可以根据重复发生的原因采取不同方式应对：
* **加强的重复（imposed duplication）。**开发者觉得他们无可选择——环境似乎要求重复。通常可以编写简单的过滤器或者代码生成器来解决这类问题，这需要发挥一点聪明才智。或者使用一些工具和套件，例如用文档生成器为代码生成文档。
* **无意的重复（inadvertent duplication）。**开发者没有意识到他们在重复信息。这种重复通常来自于设计中的错误，当我们拥有多个相互依赖的数据元素时，就容易设计出一些包含重复数据的结构。
* **无耐心的重复（impatient duplication）。**开发者偷懒，他们重复，因为那样似乎更容易。这是一种容易检测和处理的重复形式，但那需要你接受训练，并愿意为避免以后的痛苦而预先花一些时间。
* **开发者之间的重复（interdeveloper duplication）。**同一个团队（或不同团队）的几个人重复了同样的信息。这或许是最难检测和处理的重复问题。我们可以通过清晰的设计、强有力的技术项目领导，以及明确的责任划分，对这个问题加以处理。另一方面，我们要鼓励开发者相互间进行主动的交流，可以设置论坛、资料中心、开源代码等方式促进知识的互访互惠。

**Make It Easy to Reuse——让复用变得容易**
你所要做的是营造一种环境，在其中要找到并复用已有的东西，比自己编写更容易。如果不容易，大家就不会去复用。而如果不进行复用，你们就会有重复知识的风险。

>*Tips：对于代码中的注释，要把低级的知识放在代码中，它属于哪里；把注释留给其他的高级说明。否则，我们就是在重复知识，而每一次改变都意味着即要改变代码，也要改变注释。注释将不可避免地变得过时，而不可信任的注释比完全没有注释更糟。*

## 曳光弹
在开发新的项目，特别是当你构建从未构建过的东西时，相比于传统的先编写模块再进行组装的开发模式，使用曳光弹的模式往往更加行之有效。
**Use Tracer Bullets to Find the Target——用曳光弹找到目标。**
所谓曳光弹的开发模式，就是要找到某种东西，让我们能快速、直观和可重复地从需求出发，满足最终系统的某个方面要求。曳光开发与项目永不会结束的理念是一致的：总有改动需要完成，总有功能需要增加，这是一个渐进的过程。曳光代码方法有许多优点：
* **用户能够及早看到能工作的东西。**
* **开发者构建了一个他们能在其中工作的结构。**
* **你有了一个集成平台。**
* **你有了可用于演示的东西。**
* **你将能够感觉到工作进展。**

**曳光弹并非总能击中目标。**曳光代码同样也并非总是符合需求，但是它简单、惯性更小，这就意味着改变它会更容易、更迅速，你能够花费较少的代价、更为迅速地生成新的、更为准确的版本。
**曳光代码跟原型制作不一样。**原型制作生成的是用过就扔的代码，但曳光代码不是，你编写它，是为了保留它。曳光代码虽然功能简单，但却是完整的，并且构成了最终系统骨架的一部分。你可以把原型制作视为在第一发曳光弹发射之前所进行的侦察和情报收集工作。

## 估算
通过学习估算，将此技能发展到你对事物的数量级有直觉的程度，你就能确定它们的可行性，并且加深你对程序所处的世界的理解。
**Estimate to Avoid Surprises——估算，以避免发生意外。**
**理解提问内容。**任何估算的第一步都是建立对提问内容的理解，尝试思考以下两个问题：
 * **多准确才能足够准确？**首先要明确解答问题的语境，是需要高度的准确性，还是一个近似值即可。其次，要选择合适的精确度单位，时长2周以内用天，3~8周用周，8周以上单位用月会比较合适。
 * **问题域的范围是什么？**养成在开始猜想前先思考范围的习惯，找出隐含在问题中的各种假设条件，你选择的范围将会成为你解答中的一部分，可以在回答中声明这些假设条件。

**估算来自哪里。**一个简单确相当有效的估算诀窍：尝试去问已经做过这件事情的人，看看他们的问题是怎么解决的。尽管案例不大可能完全相同，但通常也会有一些值得借鉴的经验。
**建立系统的模型。**这是估算有趣的部分，根据你对所提问题的理解，建立粗略、就绪的思维模型骨架：
 * **建立模型。**对于一个项目，模型可以是你的组织在开发过程中所用的步骤、以及系统的实现方式的非常粗略的图景。但努力建模也许只能带来轻微的精确度提高，需要凭借你的经验做好权衡。
 * **把模型分解为组件。**有了模型你就可以把它分解为组件。你需要找出描述这些组件怎样交互的数学规则，通常就是找出每个组件所包含的参数及其影响。
 * **给每个参数指定值。**找出哪些参数对结果的影响最大，用于乘除运算的参数通常比常数影响更大。你应该采用合理的方式计算这些关键参数，尽量可能让它们更加正确。
 * **计算答案。**用Excel多次计算结果，找出真正主导模型的参数，根据这些参数表述你的答案。假如你得到一些看起来很奇怪的答案，尝试反思是否是问题或者模型的理解上有错误。

**追踪你的估算能力。**记录你的估算，从而让你看到自己接近正确答案的程度。如果结果非常好，会帮助你建立信心。如果结果证明估算错了，也要设法找出原因，这会使你的下一次估算变得更好。
**估算项目进度。**对大型项目进行估算时，按照【检查风险】>>【分析风险】>>【设计、实现、集成】>>【向用户确认】的步骤进行迭代，每次迭代后提升你对迭代内容的理解，逐渐掌握项目的整体进度。
**我等会再答复你。**当你在被要求进行评估时，说这句话。放慢评估速度，并花一点时间仔细检查评估步骤，基本上都能得到更好的结果，随意评估的结果可能会带来意外的麻烦。

## 调试
对于许多开发者，调试本身是一个感性的话题。你可能会遇到抵赖、推诿、借口甚至是无动于衷，但需要接受的事实是：调试就是解决问题，要据此发起进攻。
**Fix the Problem, Not the Blame——要修正问题，而不是发出指责。**
有些时候，对bug问责可能是工作文化的一部分。但是在技术竞技场上，你更应该关注于修正问题，而不是发出指责。Bug是你的过错还是别人的过错，这并不是很重要，因为它仍是你的问题。
**Don't Panic——不要恐慌。**
在开始调试之前，你需要忘掉项目、客户之类的压力，放松心情，再去思考是什么造成了bug以这种方式出现。避免在“那不可能发生”的想法上浪费时间，因为很明显，那不仅可能，而且也已经发生了。目光不能只停留在眼前看到的问题，设法找出问题的根源，而不只是问题的特定表现。
在开始查看bug时，先确保代码能够成功编译并且没有警告。其次，要收集问题相关的所有数据，仔细观察问题报告、跟反馈者交谈，以获取足够程度的细节。一旦你认为已经知道了在发生什么，就到了找出程序认为在发生什么的时候了，常用的测试策略如下：
* **重现bug。**开始修正bug的最佳途径是让其重现，尽量隔离显示出bug的环境，让重现变得简单。
* **使数据可视化。**认识程序在做什么的最佳途径是查看它操作的数据，借助调试器、绘图工具实现。
* **跟踪。**观察程序或数据随时间的状态变化，尤其是一些涉及并发、实时、事件的系统。
* **变量的邻居。**如果检查到一个坏变量，可以查看这个变量周围的内存，这常常能带给你一些线索。
* **向别人解释。**通过这种的方式，明确陈述那些自己想当然的事情，发现隐含的假定条件。

**"Select" Isn't Broken——"Select"没有问题。**
Bug有可能存在于系统、编译器、数据库、或是第三方产品中，但这不应该是你的第一想法。大多数情况下，bug存在于正在开发的应用代码中。你所做的改动很可能是导致问题的原因，尽管有时候看起来毫无关联，但被改动的东西可能在你的控制之外，直接或间接地破坏了之前正确的代码。如果无法定位问题，可以使用二分查找法，逐渐缩小范围直到最终确定问题所在。

## 何时使用异常
异常应保留给意外事件，而不是作为程序正常流程的一部分使用。假设移走所有的异常处理器，代码就不能正常工作了，那么也许异常就被使用在了非异常的情形中。
**Use Exceptions for Exceptional Problems——将异常用于异常的问题。**
异常表示即时的、非局部的控制转移。如果把异常作为正常处理流程的一部分去使用，将会破坏封装，导致调用方和被调用方被更加紧密的耦合在一起，并降低代码的可读性和可维护性。
另一种处理异常的方式是使用错误处理器，可用于代替异常，或者与异常一起使用。把对象包装在一个实现了异常处理器接口的类中，当错误发生时处理器的方法会被调用。

## 解耦与迪米特法则
**减少耦合：**把代码组织成最小组织单位（模块），并限制它们之间的交互。一个提供特定服务的对象需要替调用方完成该服务，而不是返回一个第三方对象，调用方必须对其加以处理才能获得所需服务。
**迪米特法则：**只与你的直接朋友交谈，不跟“陌生人”说话。其含义是，如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。
**Minimize Coupling Between Modules——使模块之间的耦合减至最少。**
使用迪米特法则能够帮助我们将模块之间的耦合减至最少，使你的代码适应性更好、更健壮。但也意味着你将会编写大量包装方法，这些会带来额外的运行时代价和空间开销。与任何技术一样，你必须平衡应用的各种正面和负面因素。如果模块之间的耦合能够带来重大的性能改进，并且能够被大家所接受，那这样的设计就没有问题。

## 元数据设计
元数据通常指那些对应用进行描述的数据——应用该怎样运行、它应该使用什么资源等等。在典型情况下，元数据在运行时，而不是编译时被访问和使用。
使用元数据可以让我们的系统变得高度可配置，更容易适应变化。但我们不只是想把元数据用于简单的偏好。我们想要尽可能多的通过元数据配置和驱动应用。
**Put Abstractions in Code, Details in Metadata——把抽象放进代码，细节放进元数据。**
我们的目标是以声明方式思考（规定要做什么，而不是怎么做），并创建高度灵活和可适应的程序。通常的做法是为一般情况编写程序，把具体情况放在别处（编译的代码库之外），这样做的好处：
* 解除设计中的耦合，从而带来更灵活、可适应性更好的程序。
* 通过推迟细节处理，创建更健壮、更抽象的设计。
* 无需重新编译应用，就可以对其进行定制。

## 时间耦合
通过允许并发和解除次序依赖两种方式减少时间耦合，可以获得更好的灵活性，并减少工作流、架构、设计和部署等开发领域中的时间依赖。
* **分析工作流，改善并发性。**使用UML活动图之类的表示法来对工作流进行建模和分析，找出本来可以但却没有并行执行的动作，使并行度最大化。
* **用服务进行设计。**使用合理的系统架构减少不同组件在时间上的依赖，例如，使用消息队列+服务的设计可以让一个组件在时间上解除了与其他组件的耦合。
* **总是为并发进行设计。**保护全局变量、更简洁的接口、设计支持并发的架构，在设计之初就应该考虑并发问题，以提高系统的可伸缩性和性能。

## 靠巧合编程
我们应该避免靠巧合编程——依靠运气和偶然的成功，而要深思熟虑地编程。
* **现实的偶然。**有时候尽管代码看起来能够工作，但那实际上只是一个巧合。你使用的方法或者边界条件也许只是在当前的场景下可行，换一种情形可能就会导致错误。
* **语境的偶然。**或许你只在一个语境下开发，但现实却要求你的代码在其他语境下也要能正常工作。
* **隐含的假定。**我们在工作时脑海中总是会不自觉地带上许多假定条件，但是这些假定条件却很少被记入文档，并非以明确地事实为基础的假定是所有项目的祸害。

Don't Program by Coincidence——不要靠巧合编程。
想要及时发现并修正错误，提高开发的效率，我们需要深思熟虑的编程：
* **总是意识到你在做什么。**别让事情慢慢地失去了控制。
* **不要盲目地编程。**不要使用不理解、或不熟悉的技术。
* **按照计划行事。**执行前做好计划，无论是简单的还是详细的。
* **依靠可靠的事务。**不要依靠巧合或假定。
* **为你的假定建立文档。**澄清你的假定，并传达出去。
* **不要只是测试你的代码。**测试你的假定，不要猜测，要实际去尝试。
* **为你的工作划分优先级。**把时间花在重要的方面。
* **不要做历史的奴隶。**不要让已有的代码支配将来的代码，必要时进行重构。

所以下次有什么东西看起来能工作，而你却不知道为什么，要确定它不是巧合。